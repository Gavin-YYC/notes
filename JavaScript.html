
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
  
  JavaScript - 我的笔记整理
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习笔记归纳整理">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="我的笔记整理" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">我的笔记整理</a></h1>

    <h2>学习笔记归纳整理</h2>

</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>

</ul>

<form action="http://baidu.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>

<ul class="main-navigation">
  <li><a href="index.html">Home</a></li>
  <li><a href="archives.html">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631212906232.html">JavaScript：被忽视的细节</a></h1>
			<p class="meta"><time datetime="2016-05-13T14:34:50+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>《JavaScript 权威指南》这本书从第四版开始，一直到第六版，每个版本我都逐字逐句读过几遍，然而每一遍下来的感受却完全不一样。上上周的周一，再次翻开了这本犀牛书，这一次我是带着批判精神和研究精神过来的，所以看的时候也写下了一些感受和笔记，都是些容易被忽略的点，部分内容犀牛书上不一定有提到。 <br/>
之前都发在微博上，稍微整理了一番，放在这里，方便阅读。 </p>

<h2 id="toc_0">语句/表达式 </h2>

<p>换个角度理解语句（statemaents）和表达式（expressions）：表达式不会改变程序的运行状态，而语句会。还有一种叫做表达式语句，可以理解为表达式和语句的交集，如 <code>({a:1})</code>、<code>&quot;use strict;&quot;</code>等，我觉得没必要死扣，意义不大。</p>

<h2 id="toc_1">字符集</h2>

<p>ES3 要求 JS 必须实现 <code>Unicode 2.1</code> 及后续版本，而 ES5 只要求支持 <code>Unicode 3</code> 及后续版本。Unicode 字符 2005 年超过了十万字符，至今仍在不断增修，最新版本是 8.0。 </p>

<h2 id="toc_2">分号</h2>

<p> <br/>
如果你写 JS 代码不喜欢带分号，而又搞不清什么时候必须加分号，可以这么做：在以 <code>“(“</code>、<code>”[“</code> 、<code>”/“</code>、<code>”+”</code>、<code>”-“</code>开头的语句前面都加上一个分号，如 </p>

<pre><code>;(a + b).toString()。 
</code></pre>

<h2 id="toc_3">进制 </h2>

<p>ES5 严格模式中禁止使用八进制。目前各种引擎对 JS 的实现是存在差异的，部分支持八进制，部分不支持。八进制被禁止的原因：<code>String</code>和<code>Number</code>之间经常被相互转换，而以<code>0</code>开头的八进制数据特别容易让人迷惑，也容易让机器迷惑，比如<code>09</code>是该被转换成<code>9</code>还是直接报错？十六进制不存在这个问题，如 <code>0x98</code>。更多信息参阅 这里。</p>

<h2 id="toc_4">精度 </h2>

<p>JS 采用 <code>IEEE-754</code> 浮点数表示法，这是一种二进制表示法，由于精度原因 JS 不能表示所有的实数。它能展示的浮点数个数是有限的，比如它不能准确地表示三分之一的数值字面量。这也导致了它在浮点数的计算上存在误差，如 </p>

<pre><code>0.3 - 0.2 != 0.2 - 0.1
</code></pre>

<p>因为在计算的过程中，存在数据的溢出，丢失了精度。</p>

<pre><code>0.3 - 0.2 // 0.09999999999999998
0.2 - 0.1 // 0.1
</code></pre>

<h2 id="toc_5">null/undefined </h2>

<p>系统级、出乎意料的或者类似错误的值的空缺使用 <code>undefined</code>，而程序级、正常的或意料之中的值的空缺使用 <code>null</code>。平时编程给变量赋值时，不要使用 <code>undefined</code> 而应该用 <code>null</code>。值得注意的是 ES3 中的 undefined 是可以被重新赋值的，ES5 修复了这个 bug。通常我们使用 <code>void 0</code> 来还原/代替 undefined 的值。</p>

<h2 id="toc_6">eval </h2>

<p><code>eval</code> 是个不好把握的东西，它在 ES3 中更像是 <code>Function</code>，而在 ES5 中更像是一个运算符（严格模式下不允许设置别名，否则报错，且将其作为保留字）。实际上 ES3 中也不允许给 eval 设置别名，然而很多实现却依然允许，并将其作为全局代码来执行，浏览器尤其是 IE 对它实现相当混乱，没有什么规律可循，不过 IE 中提供了一个 <code>execScript</code> 函数，类似全局的 <code>eval</code>，这个函数每次执行都会返回 <code>null</code>。</p>

<p>需要使用 <code>eval</code> 的场景并不多，尽量少用，一般需求使用 <code>new Function</code> 就能满足。</p>

<h2 id="toc_7">引用 </h2>

<p>删除属性存在的坑：</p>

<pre><code>a = {
    n: {
        x: 2
    }
}, 
b = a.n; 
delete a.n; 
</code></pre>

<p>这段代码执行之后，b.x 依然等于 2，原因是 {x:2} 这个对象被 a 和 b 同时引用，delete 指令只删除了 a 对它的引用，b 上的引用依然存在。这种问题有可能造成内存泄漏。</p>

<h2 id="toc_8">Object 扩展 </h2>

<p><code>Object</code> 的 <code>freeze</code> 方法过于严格；<code>defineGetter/lookupGetter</code>和对应的 <code>Setter</code> 是很好用的属性。</p>

<pre><code>value
writable
enumerable
configurable

create -&gt; __proto__
get -&gt; __defineGetter__ / __lookupGetter
set -&gt; __defineSetter__ / __lookupSetter

defineProperty / defineProperties -&gt; isPeopertyOf / hasOwnProperty

getOwnPropertyName
getOwnPropertyDescriptor

preventExtensions -&gt; esExtensions

seals -&gt; isSealed
freeze -&gt; isFrozon 
</code></pre>

<h2 id="toc_9">toLocalString </h2>

<p>如图，你可能还不知道 JavaScript 的 <code>toLocaleString</code> 还可以这么玩。</p>

<pre><code>1234567..toLocaleString( &#39;zh-Hans-CN-u-nu-hanidec&#39;, {
    useGrouping: false
});
//一二三四五六七
1234567..toLocaleString( &#39;zh-Hans-CN-u-nu-hanidec&#39;, {
    useGrouping: true
});
//一,二三四,五六七 
</code></pre>

<h2 id="toc_10">this语义</h2>

<p>this 上下文只存在两种语义，一种是被当作方法调用，this 指向调用它的对象；一种是作为函数调用，指向 <code>Global</code> 对象（严格模式下为 undefined）。它没有作用域的限制，如下图所示，a 由于是作为函数被调用，所以它指向的是 window，故而返回 false。</p>

<pre><code>var o = {
    m: function () {
        var that = this;
        a();

        function a () {
            console.log( this === that );
        }
    }       
}
o.m();
// false
</code></pre>

<h2 id="toc_11">类型 </h2>

<p>JavaScript 可以被调用执行的均为 <code>Function</code> 类型，但是也存在可调用的 <code>Object</code>，如低版本 IE 中的一些宿主对象：<code>document.getElementById</code>、<code>alert</code> 等，在很多浏览器中<code>typeof</code> <code>RegExp</code> 同样是 Object。这绝对是一个不标准的实现，在浏览器摒弃/修正这些错误类型之前应该尽量少依赖它们。 </p>

<h2 id="toc_12">IE8 getter/setter </h2>

<p><code>Object.defineProperty</code> 虽然是 ES5 的东西，早在 IE8 就已经支持了，但支持得并不完善，比如 <code>writable</code>、<code>enumerable</code>、<code>configurable</code> 这些配置项设置就无效，IE8 下主要支持 <code>getter/setter</code>。</p>

<h2 id="toc_13">JSON.stringify </h2>

<p><code>JSON.stringify</code> 接受三个参数，很多人都知道第<code>三</code>个参数可以设置空白字符来美化输出，但是你可能不知道第<code>二</code>个参数的作用，它为 <code>{Array|Function}</code> 类型，如果为 <code>Array</code> 则用于过滤 <code>key</code>，如果为 <code>Function</code> 则可以对 <code>value</code> 做处理，如下。</p>

<pre><code>var obj = {
    a: {
        b: {
            c: 1,
            d: 2
        }
    }
}   JSON.stringify( obj, function ( k, v ) {
    if ( typeof v === &#39;number&#39; ) {
        return &#39;v&#39; + v;
    } else {
        return &#39;v&#39;;
    }
}, 2);
// output
&quot;{
    &quot;a&quot;: {
        &quot;b&quot;: {
            &quot;c&quot;: &quot;v1&quot;,
            &quot;d&quot;: &quot;v2&quot;
        }
    }
}&quot; 
</code></pre>

<h2 id="toc_14">Symbol </h2>

<p><code>ES6</code> 中添加了一种新的数据类型，<code>Symbol</code>，它是一种原始数据类型（图一），具备对象的特性（图二），并可以指向同一个引用（图三），能够作为对象的 <code>key</code> 但不可枚举（图四），内置的 <code>Symbol</code> 会影响程序的执行（图五），<code>Symbol.iterator</code> 是个举足轻重的符号，能够让元素具备迭代属性（图六），花样很多。<br/>
 附图见：<a href="http://weibo.com/1812166904/DqMwR8O6z">http://weibo.com/1812166904/DqMwR8O6z</a></p>

<p>伪数组添加 <code>Symbol.iterator</code> 的几个办法：鸭式辨型的 <code>iterator</code> 函数、<code>yield</code> 函数和直接使用 <code>Array</code> 的遍历符号。<br/>
 <br/>
附图见：<a href="http://weibo.com/1812166904/DqMBYe">http://weibo.com/1812166904/DqMBYebPw</a></p>

<h2 id="toc_15">Set/WeakSet</h2>

<p><code>Set/WeakSet</code> 这种数据结构，不能说没用，但确实也没啥大用，前者就是个不允许出现重复成员的数组，顺便还带了点 ES6 的特性，后者虽说可以一定程度上防止内存泄漏，但是也容易出错，比如某个引用已经被垃圾回收了，再去使用它可能就返回 null。它们都是 ES6 的配套产物。而 Map/WeakMap 倒是两个非常不错的设计，常规的 Object 结构都为 String-Val 键值对，而它扩展为 AllType-Val，任意类型都可以作为它的 Key，无论是服务端编程还是客户端编程，这个属性都带来了极大的便利性。</p>

<pre><code>var map = new Map();
var o = { a: 1 };

map.set( o, 555 );
map.get( o );
// 555  
</code></pre>

<h2 id="toc_16">正则 </h2>

<p>理解正则零宽的含义：正则中所谓的零宽断言，类似于锚点字符，它们匹配指定的位置而不会匹配内容，如 ^ 匹配开头，$ 匹配结尾，b 匹配单词边界；(?=p) 匹配「接下来的字符与 p 匹配」的位置，(?!p) 匹配「接下来的字符不与 p 匹配」的位置。b 字符匹配单词边界，实际上就是匹配 w 与 W 之间的位置（w 匹配 [a-zA-Z0-9]）。很少会有人用到 B，它匹配的是非单词边界位置，简单理解就是 w &amp; w 之间位置或者 W &amp; W 之间位置。</p>

<pre><code>&quot;hello    world&quot;.match(/\B\w+\B/g);
// [&#39;ell&#39;, &#39;orl&#39;]
&quot;hello     world&quot;.match(/\B\W+\B/g);
// [&#39;   &#39;]
</code></pre>

<p>持续学习和分享… </p>

<p>内容都是片段化的分享，比较多，也比较杂，就没有全部列举出来，感兴趣的同学可以 follow 我的 微博，我的想法和笔记都会在上面同步。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631105630408.html">JavaScript：throttle and debounce</a></h1>
			<p class="meta"><time datetime="2016-05-13T11:36:03+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">1、概念介绍</h2>

<p>首先，<strong>throttling</strong> 与 <strong>debouncing</strong> 都可以对执行的函数进行速率限制。</p>

<p><strong>throtting</strong>：在一段时间内，对调用函数的最大次数进行限制，比如：在100ms内最多执行一次该函数。</p>

<p>举个例子，如果你的函数会在10s内执行1000次，比如触发<code>scroll</code>事件，这时候性能开销就比较大，我们可以使用throttle进行控制，让函数每100ms执行一次，这样，10s内最大执行的次数为100次，有效减少了性能开销。</p>

<p><img src="http://gavin-y.qiniudn.com/throttle.png" alt="throttle"/></p>

<p><strong>debouncing</strong>：经过一段时间以后才执行相应的函数。并且该函数只执行一次，比如：100ms以后才执行和这个函数。</p>

<p>举个例子：如果你的函数会在10s内执行1000次，比如触发<code>scroll</code>事件，当我们加上debounce的特效后，设置经过100ms后执行，Duang的一下，函数不会再这10s内执行了，相反，它会在事件结束后开始算起，经过100ms执行，也就是说在10.1s执行的该函数。</p>

<p><img src="http://gavin-y.qiniudn.com/debounce.png" alt=""/></p>

<h2 id="toc_1">2、演示</h2>

<p>在<a href="http://underscorejs.org/">underscore</a>中提供了<a href="http://underscorejs.org/#throttle">_.throttle()</a>与<a href="http://underscorejs.org/#debounce">_.debounce()</a>方法，下面使用这两个方法进行演示，可以明显的看到两个方法的不同。</p>

<p>代码如下：</p>

<pre><code>// throttle
$( window ).on( &#39;scroll&#39;, _.throttle( func, 200 ) );

// debounce
$( window ).on( &#39;scroll&#39;, _.debounce( func, 200 ) );
</code></pre>

<iframe style="width: 100%; height: 672px; border: 1px solid #ccc" src="http://sandbox.runjs.cn/show/xcdkk9av" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="toc_2">2、debounce</h2>

<p>上面演示了通过underscore提供的方法实现throttle与debounce，下面具体来看看怎么实现。我们先从最简单的debounce入手，假设只需要提供两个参数：</p>

<ul>
<li><strong>fn</strong>：回调函数</li>
<li><strong>wait</strong>：多长时间执行一次</li>
</ul>

<p>该部分实现比较简单，下面是实现代码：</p>

<pre><code>var debounce = function ( fn, wait ) {
    var timer = null;
    return function () {
        var context = this, args = arguments;
        clearTimeout( timer );
        timer = setTimeout( function () {
            fn.apply( context, args );
        }, wait );
    }
}
</code></pre>

<p>来演示一下：</p>

<pre><code>// 使用方式
var fn = function () {
    // do something
}
$( window ).on( &#39;scroll&#39;, debounce( fn, 200 ) );
</code></pre>

<iframe style="width: 100%; height: 240px; border: 1px solid #ccc" src="http://sandbox.runjs.cn/show/l9ybgqqo" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>上面通过闭包的方式来实现，因为当我们在调用debounce的时候执行的是一个函数，所以在debounce中，需要返回这么一个函数。</p>

<h2 id="toc_3">3、throttle</h2>

<p>上面说完了debounce的创建方式，下面说说throttle的创建方式。</p>

<p>其实，个人认为throttle是debounce的升级版，因为throttle是事件结束后然后在一段时间后才去执行相应函数，那么，有时候我们需要对这个执行过程进行控制，默认的浏览器渲染大约在16~17ms之间（通过最上面的demo的第一个可以看出），那么，如果是我们不想函数执行的这么频繁，即使50ms或者100ms也看不出任何的破绽，那么，我们宁愿使用100ms来执行函数，这也是throttle的作用。</p>

<p>下面我们还是实现比较简单的throttle，进行事件频率限制，同样，该方法接收两个参数：</p>

<ul>
<li><strong>fn</strong>：回调函数</li>
<li><strong>wait</strong>：每多少ms执行一次回调函数</li>
</ul>

<p>实现方式：</p>

<pre><code>var throttle = function ( fn, wait ) {\
    var last  = 0;
    return function () {
        var context = this;
        var curr = + new Date();
        if ( curr - last &gt;= wait ) {
            fn.call( context );
            last = curr;
        }
    }
}
</code></pre>

<p>使用方式：</p>

<pre><code>var fn = function () {
    // do something
}

$( window ).on( &#39;scroll&#39;, throttle( fn, 100 ) );
</code></pre>

<p>过程解释：</p>

<ul>
<li>一开始记录一个时间点</li>
<li>随着事件的触发，获取当前触发事件的时间点，判断该时间与事件开始时记录的时间相差是不是大于设定的值</li>
<li>如果大于设定的值，则执行函数</li>
<li>如果不大于，则什么也不做</li>
</ul>

<iframe style="width: 100%; height: 240px; border: 1px solid #ccc" src="http://sandbox.runjs.cn/show/r55gmjta" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="toc_4">4. 简单的封装实现</h2>

<pre><code>/**
 * throttle 
 * @param  fn, wait, debounce
 */
var throttle = function ( fn, wait, debounce ) {
    var timer = null,       // 定时器
        t_last = null,  // 上次设置的时间
        context,    // 上下文
        args,       // 参数
        diff;       // 时间差

    return funciton () {
        var curr = + new Date();
        var context this, args = arguments;
        clearTimeout( timer );
        if ( debounce ) {   // 如果是debounce
            timer = setTimeout( function () {
                fn.apply( context, args );
            }, wait );
        } else {            // 如果是throttle
            if ( !t_last ) t_last = curr;
            if ( curr - t_last &gt;= wait ) {
                fn.apply( context, wait );
                context = wait = null;
            }
        }
    }
}

/**
 * debounce
 * @param fn, wait
 */
var debounce = function ( fn, wait ) {
    return throttle( fn, wait, true );
}
</code></pre>

<p>注：该封装是一个简单的实现封装，抛掉了一些我自己觉得不必要存在的东西，比如说大多数的throttle的实现都有一个setTimeout的步骤，个人觉得如果时间小于多少的时候，timer会一直被覆盖没有发挥作用，所以就先去掉了。</p>

<h2 id="toc_5">5、underscore的实现方式理解</h2>

<pre><code>_.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;     // 定时器
    var previous = 0;       // 上次触发的时间
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();

      // 第一次是否执行
      if (!previous &amp;&amp; options.leading === false) previous = now;

      // 这里引入了一个remaining的概念：还剩多长时间执行事件
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      // remaining &lt;= 0 考虑到事件停止后重新触发或者
      // 正好相差wait的时候，这些情况下，会立即触发事件 
      // remaining &gt; wait 没有考虑到相应场景
      // 因为now-previous永远都是正值，且不为0，那么
      // remaining就会一直比wait小，没有大于wait的情况
      // 估计是保险起见吧，这种情况也是立即执行
      if (remaining &lt;= 0 || remaining &gt; wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;

      // 是否跟踪
      } else if (!timeout &amp;&amp; options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
};
</code></pre>

<p>由上可见，underscore考虑了比较多的情况：</p>

<ul>
<li>options.leading： 第一次是否执行，默认为true，表示第一次会执行，传入{leading:false}则禁用第一次执行</li>
<li>options.trailing：最后一次是否执行，默认为true，表示最后一次会执行，传入{trailing: false}表示最后一次不执行</li>
<li>所谓第一次是否执行，是刚开始触发事件时，要不要先触发事件，如果要，则previous=0，remaining 为负值，则立即调用了函数</li>
<li>所谓最后一次是否执行，是事件结束后，最后一次触发了此方法，如果要执行，则设置定时器，即事件结束以后还要在执行一次。</li>
<li>remianing &gt; wait 表示客户端时间被修改过。</li>
</ul>

<hr/>

<pre><code>// immediata 表示是否立即执行
_.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last &lt; wait &amp;&amp; last &gt;= 0) {
        // 该过程会频繁进行，直到last&gt;wait
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate &amp;&amp; !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      // 如果立即调用
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
};
</code></pre>

<h2 id="toc_6">6、使用场景</h2>

<ul>
<li>scroll resize 事件</li>
<li>文本输入自动完成</li>
<li>鼠标移动，拖动的情况</li>
<li>DOM元素的动态定位</li>
<li>......</li>
</ul>

<h2 id="toc_7">6、参考资料</h2>

<ul>
<li><p><a href="https://css-tricks.com/the-difference-between-throttling-and-debouncing/">https://css-tricks.com/the-difference-between-throttling-and-debouncing/</a></p></li>
<li><p><a href="http://www.css88.com/archives/4648">javascript函数的throttle和debounce</a></p></li>
<li><p><a href="http://www.alloyteam.com/2012/11/javascript-throttle/">浅谈javascript的函数节流</a></p></li>
<li><p><a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/">jQuery throttle / debounce: Sometimes, less is more!</a></p></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631105630335.html">JavaScript：scrollIntoView</a></h1>
			<p class="meta"><time datetime="2016-05-13T11:36:03+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>scrollIntoView可以实现让元素滚动到视图(可视)范围内，其接受一个可选参数，true / false</p>
</blockquote>

<h2 id="toc_0">1.使用方法</h2>

<p>使用方法：</p>

<pre><code>ele.scrollIntoView( arg );
</code></pre>

<h2 id="toc_1">2、参数介绍</h2>

<h3 id="toc_2">2.1 参数是boolean形式</h3>

<p>如果是：<code>true</code>，则表示元素滚动到视图的<code>顶部</code>，默认为<code>true</code></p>

<pre><code>ele.scrollIntoView( true );
</code></pre>

<p>如果是：<code>false</code>，则表示元素滚动到视图的<code>底部</code></p>

<pre><code>ele.scrollIntoView( false );
</code></pre>

<h3 id="toc_3">2.2 参数是对象形式</h3>

<blockquote>
<p>这种形式，目前只有firefox 36+支持。</p>
</blockquote>

<p>另外，其还接受一个对象格式：<code>scrollIntoViewOptions</code>，其有如下选项：</p>

<pre><code>{
    behavior: &quot;auto&quot;  | &quot;instant&quot; | &quot;smooth&quot;,
    block:    &quot;start&quot; | &quot;end&quot;
}
</code></pre>

<p>其中<code>behavior</code>默认是<code>instance</code>，<code>block</code>默认是<code>start</code>。</p>

<p>调用方式如下：</p>

<pre><code>ele.scrollIntoView({
  behavior: &quot;smooth&quot;,
  block:    &quot;end&quot;
});
</code></pre>

<blockquote>
<p>注意：</p>

<p>如果block是“start”，相当于设置了参数：true</p>

<p>如果block是“end”，相当于设置了参数：false</p>
</blockquote>

<h2 id="toc_4">3、具体示例</h2>

<p><a href="http://sandbox.runjs.cn/show/u1ogecdw">Demo地址</a></p>

<blockquote>
<p>注意：节点可能不会特别准确的滚动到滚动区域的上边界或者下边界，这取决于其他元素的布局。</p>

<p>Depending on the size of the given object and the current window, this method might not be able to put the item at the very top or very bottom, but will position the object as close to the requested position as possible.</p>
</blockquote>

<h2 id="toc_5">4、浏览器兼容性</h2>

<p><img src="http://7mj4a6.com1.z0.glb.clouddn.com/23482348923.png" alt="浏览器兼容性：http://7mj4a6.com1.z0.glb.clouddn.com/23482348923.png"/></p>

<h2 id="toc_6">5、scrollIntoViewIfNeeded(align)</h2>

<p>该属性和<code>scrollIntoView</code>属性类似，不同的是，这个属性可以实现自我判断，只有元素不在可视区域内才会滚动到可视区。</p>

<p>如果元素已经在可视区，则不会发生滚动。</p>

<p>该方法同样接受一个参数，是否居中显示，<code>true</code>表示垂直居中， <code>false</code>表示什么都不做。</p>

<h2 id="toc_7">5、资料来源</h2>

<ul>
<li><p><a href="https://www.w3.org/TR/2009/WD-html5-20090423/editing.html#dom-scrollintoview">https://www.w3.org/TR/2009/WD-html5-20090423/editing.html#dom-scrollintoview</a></p></li>
<li><p><a href="https://msdn.microsoft.com/en-us/library/ms536730(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/ms536730(v=vs.85).aspx</a></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoViewIfNeeded">https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoViewIfNeeded</a></p></li>
<li><p><a href="http://caniuse.com/#search=scrollintoview">http://caniuse.com/#search=scrollintoview</a></p></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631105630249.html">JavaScript：Web Notifications</a></h1>
			<p class="meta"><time datetime="2016-05-13T11:36:03+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">1、安全性</h2>

<p>要呈现通知需要获得用户的许可。</p>

<h2 id="toc_1">2、模型</h2>

<p>1、每个模型都有标题、方向、语言和来源</p>

<p>2、每个通知都要有与之相关的内容（body）、标签（tag）、图标地址（icon URL）和图标（icon image）。</p>

<h3 id="toc_2">2.1 direction</h3>

<h3 id="toc_3">2.2 language</h3>

<h3 id="toc_4">2.3 permission</h3>

<p>如果用户准许，就可以使用notification，其权限permission可以是如下三个字符串：</p>

<ul>
<li><code>default</code>: 和<code>denied</code>一样，只用户没有做出选择。</li>
<li><code>denied</code>: 指用户拒绝接收通知</li>
<li><code>granted</code>: 指用户同意展示通知</li>
</ul>

<h3 id="toc_5">2.4 notification list</h3>

<h3 id="toc_6">2.5 展示通知</h3>

<p>步骤：</p>

<h2 id="toc_7">方法</h2>

<table>
<thead>
<tr>
<th>事件处理器</th>
<th>事件类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>onclick</td>
<td>click</td>
</tr>
<tr>
<td>onshow</td>
<td>show</td>
</tr>
<tr>
<td>onerror</td>
<td>error</td>
</tr>
<tr>
<td>onclose</td>
<td>close</td>
</tr>
</tbody>
</table>

<h2 id="toc_8">一个通知构造的过程</h2>

<p>Notification(title, options);</p>

<p>1、实例化Notification通知对象</p>

<p>2、设置通知对象的标题</p>

<p>3、根据options中的<code>dir</code>设置通知对象的<code>direction</code></p>

<p>4、如果选项的<code>lang</code>存在，则设置<code>language</code>，否则设置为诶空</p>

<p>5、根据当前的源设置通知的来源</p>

<p>6、如果options中的<code>body</code>存在，设置通知的<code>body</code></p>

<p>7、如果options中的<code>tag</code>存在，设置通知的<code>tag</code></p>

<p>8、如果options中的<code>icon</code>存在，使用<code>API base URL</code>解析icon</p>

<p>9、返回通知，继续异步执行其他步骤</p>

<p>10、执行通知的展示步骤</p>

<h2 id="toc_9">展示通知的步骤</h2>

<p>1、如果通知源的权限不是<code>granted</code>，则取消任何的操作，执行error事件，终止其他步骤。</p>

<p>2、</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631105630166.html">JavaScript：Geolocation</a></h1>
			<p class="meta"><time datetime="2016-05-13T11:36:03+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>geolocation是navigator中的方法，可以获取用户的位置信息，包括经纬度、海拔高度、当前的方向以及运动速度等信息。</p>
</blockquote>

<p>GeoLocation有三个方法：<code>getCurrentPosition()</code>，<code>watchPosition()</code>，<code>clearWatch()</code>。</p>

<h2 id="toc_0">1、getCurrentPosition()</h2>

<pre><code>if ( navigator.geolocation) {
  navigator.geolocation.getCurrentPosition( successCallback, failCallback, options );
} else {
  alert( &quot;你的浏览器不支持获取位置信息！&quot; )
}
</code></pre>

<p>上面，<code>successCallback</code>、<code>failCallback</code>、<code>options</code>分别对应着成功时的回调、失败时的回调、以及参数。例子如下：</p>

<pre><code>function successCallback ( location ) {
  console.log( location );
}
function failCallback ( error ) {
  console.log( error );
}
</code></pre>

<h2 id="toc_1">2、参数配置</h2>

<p>上述<code>options</code>可以设置获取位置时的参数，参数配置可以定义是否开启高精度定位、超时设定、应用程序缓存时间：</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>默认值</th>
</tr>
</thead>

<tbody>
<tr>
<td>enableHighAccuracy</td>
<td>是否高精度定位</td>
<td>false</td>
</tr>
<tr>
<td>timeout</td>
<td>等待响应的最大时间</td>
<td>infinity（无限大）</td>
</tr>
<tr>
<td>maximumAge：</td>
<td>应用程序缓存时间</td>
<td>0</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">3、获取的位置信息</h2>

<p>以上述successCallback为例，返回获取的位置信息：</p>

<pre><code>function successCallback ( location ) {
  var info = location.coords;
  $(&quot;body&quot;).html( location.timestamp + &quot;--&quot; + info.latitude + &quot;,&quot; + info.longitude);
}

// 页面效果为
1459324546863--40.1234,116.1203
</code></pre>

<p>请求成功后，返回数据对象，其信息为：</p>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>coords.latitude</td>
<td>十进制数的纬度</td>
</tr>
<tr>
<td>coords.longitude</td>
<td>十进制数的经度</td>
</tr>
<tr>
<td>coords.accuracy</td>
<td>位置精度</td>
</tr>
<tr>
<td>coords.altitude</td>
<td>海拔，海平面以上以米计</td>
</tr>
<tr>
<td>coords.altitudeAccuracy</td>
<td>位置的海拔精度</td>
</tr>
<tr>
<td>coords.heading</td>
<td>方向，从正北开始以度计</td>
</tr>
<tr>
<td>coords.speed</td>
<td>速度，以米/每秒计</td>
</tr>
<tr>
<td>timestamp</td>
<td>响应的日期/时间</td>
</tr>
</tbody>
</table>

<p>需要注意的事，往往高度得到的信息不准确，及时是使用比较专业的GPS设置，获取的高度信息也不会很精确，但经纬度一般较为精确。</p>

<p>另外，一般来讲，经纬度和位置精度是有数据返回的，其他的数据可能会返回null。</p>

<h2 id="toc_3">4、错误处理</h2>

<p>在使用的过程中可能会发生错误，比如用户不允许打开定位、定位请求超时、获取信息失败等。如果请求发生错误，会自动触发第一条中的<code>errorCallback</code>回调，传入一个<code>error</code>对象，<code>error</code>对象包括<code>code</code>与<code>message</code>两个属性，即对应的错误代码和错误信息。</p>

<table>
<thead>
<tr>
<th>编号</th>
<th>常量</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>1</td>
<td>PERMISSION_DENIED</td>
<td>用户选择拒绝浏览器获取其位置信息</td>
</tr>
<tr>
<td>2</td>
<td>POSITION_UNAVAILABLE</td>
<td>尝试获取用户位置数据，但失败了</td>
</tr>
<tr>
<td>3</td>
<td>TIMEOUT</td>
<td>获取用户位置时超时(如果设置了可选的timeout值)</td>
</tr>
</tbody>
</table>

<h2 id="toc_4">5、watchPosition()</h2>

<p>DEMO地址：<a href="http://sandbox.runjs.cn/show/ptjwtkat">watchPosition</a></p>

<p>除了<code>getCurrentPosition()</code>方法之外，还有一个获取位置信息的方法是<code>watchPosition()</code>，该方法不仅可以获取用户的位置信息，而且如果用户的位置信息发生变化，会自动触发<code>successCallback</code>，从而更新位置信息。</p>

<p>如果实在移动中的设备或者高精度设备可以使用方法。</p>

<h2 id="toc_5">6、clearWatch()</h2>

<p>停止<code>watchPosition()</code>方法。</p>

<h2 id="toc_6">7、高德地图API</h2>

<p>遇到的问题是，通过高德地图来定位与直接通过geolocation获取定位有时候获取的位置信息不一致。而高德地图获取的位置更精确一点。</p>

<p>在高德地图上可以查看其定位原理：<a href="http://lbs.amap.com/getting-started/locate/">这里</a>。</p>

<p>高德地图采用的是混合定位（也叫wifi定位）：GPS+基站+wifi的混合定位方式。</p>

<h2 id="toc_7">8、位置保密</h2>

<p>用户打开需要获取位置信息的网站的时候，会弹出一个窗口来询问用户是否同意网站获取你的当前位置信息。</p>

<p>这是一种对用户信息的一种保密，一般用户可以在自己的浏览器上设置位置信息对哪些网站可用，比如chrome，在高级设置的隐私设置中：</p>

<p><img src="http://7mj4a6.com1.z0.glb.clouddn.com/20160330042606274.png" alt="pic"/></p>

<h2 id="toc_8">9、推荐链接</h2>

<p><a href="https://developers.google.com/web/fundamentals/native-hardware/user-location/?hl=en">https://developers.google.com/web/fundamentals/native-hardware/user-location/?hl=en</a></p>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="JavaScript.html"><strong>JavaScript&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="jQuery.html"><strong>jQuery&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="css3.html"><strong>css3&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="other.html"><strong>other&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript.html"><strong>http&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Backbone.html"><strong>Backbone&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="14631573927160.html">Backbone：了解model的set与事件触发</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14631251677698.html">css3：radial-gradient</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14631212906232.html">JavaScript：被忽视的细节</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14631211935835.html">谈谈HTTP协议中的短轮询、长轮询、长连接和短连接</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14631105630408.html">JavaScript：throttle and debounce</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>



</body>
</html>