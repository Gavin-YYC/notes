
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
  
  我的笔记整理
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习笔记归纳整理">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="我的笔记整理" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">我的笔记整理</a></h1>

    <h2>学习笔记归纳整理</h2>

</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>

</ul>

<form action="http://baidu.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>

<ul class="main-navigation">
  <li><a href="index.html">Home</a></li>
  <li><a href="archives.html">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14632088730610.html">优供1.5.1 项目总结</a></h1>
			<p class="meta"><time datetime="2016-05-14T14:54:33+08:00" 
			pubdate data-updated="true">2016/5/14</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>这是第一次接触的较完整的开发任务，中间出现了一些问题，经过对这些问题的归类，大致包括这几类：排期、buffer、接口、测试。下面分开来说说遇到的问题与一些想法。</p>

<h2 id="toc_0">1、需求不明确</h2>

<p>本次的主要开发任务是：品牌筛选与秒杀页面。</p>

<p>其中品牌筛选安排的排期为1d，秒杀页面前端实现为1.5d，联调2d。然而在开发过程中，实际的开发成本是：品牌筛选2d，秒杀页面2d。但是项目提测后，bug比较多，修复的时间比较长。</p>

<p>可见，每一个开发任务都有延期，并且延期也比较大。下面是我总结的一部分原因：</p>

<pre><code>1. 自己没有把需求完全拆分，只是拆分的大层面，小层面没有注意到
2. 品牌筛选开发1d完成，但是后期后端进行接口调整，前端需要进行重新调整，多消耗0.5d
3. 品牌筛选后期，QA提需求，要求品牌筛选按钮一直显示在最顶部，又对品牌筛选的业务进行处理
4. 自己理解的只有一级分类切换品牌才会获取品牌，二级分类共享一级分类品牌，这个理解是错误的，导致后期又作了修改
5. 秒杀页面也是在自己定的时间内1.5d完成前端实现，主要是后期修改
6. 秒杀页面没有考虑到没有秒杀商品的情况，需要做处理，没有UI图
7. 秒杀的时间显示没有考虑到跨天显示的情况，需要做处理，没有UI图
8. 秒杀没有商品时，也不要显示秒杀规则，这个也没有提前弄清楚
</code></pre>

<p>从以上问题中可以看出来，大多数问题都是因为自己对需求了解不深导致的，很多问题没有在前期解决掉，导致后期不断的尽心修改。</p>

<p>下面针对自己对需求认识不深做出改进，比如：</p>

<p>每一个需求，多打几个问好，不要忘记极端情况，已秒杀页面为例：</p>

<pre><code>1. 接口返回内容为空怎么办，页面如何显示？比如：品牌分类不显示、显示暂无秒杀商品
2. 如果内容为空，其相关内容该如何显示？比如：品牌按钮不显示、秒杀规则不显示
3. 如果内容返回的数据很多怎么办？需不需要分页或触底加载？
4. 内容过长、过短怎么办？内容为连续数字与英文该怎么显示？
5. 页面滚动时怎么办？要固定还是随内容滚动？
6. ...
</code></pre>

<p>以上从极端情况上手考虑该如何处理与如何显示，可以作为一种思路，依靠这种思路能解决掉之前遇到的一些问题。另外，这些需求一定要<strong>与PM进行沟通与讨论</strong>，而不是自己妄想来的，自己的妄想不能解决任何问题，要按<strong>确切的、有思想的、有验证的</strong>需求进行开发。</p>

<h2 id="toc_1">2、排期与buffer</h2>

<p>排期与需求紧密联系，对需求把握好了，就能安排好排期，个人认为大部分的排期不好或者delay都多数因为对需求的认知存在问题。</p>

<p>就比如我在上面遇到的问题，大多数都是对需求模棱两可，按照自己揣测的方案进行开发，导致最后出现了问题。</p>

<p>而且我的排期比较紧，自己认为会在这一段时间内完成，但是丝毫没有注意到可能受到的影响，一旦中间出现问题，我这个排期就扛不住了。扛不住就只能delay了。</p>

<p>解决方式（buffer）：</p>

<pre><code>1. 留足前期buffer
     前期buffer用于技术调研、业务代码学习、完成解决方案等
     如果项目时间宽松可以考虑为2-3d，具体根据功能与需求来定

2. 项目开发过程中，也要有一些buffer
     尽量自己的开发过程安排的宽松些，保证开发与自测的时间

3. 联调buffer
     保证联调时间，可留的充分一些

4. 上线buffer
     之所以留上线buffer，是要给自己一个总结的时间，上线完先不
     要着急进行新业务的开发，要给自己一个buffer的时间进行总结与回顾。
</code></pre>

<p>虽然看上去buffer可以解决一切，但是这建立在对需求的详细了解上，以及对整个项目的掌控，同时，也要结合PM、RD、QA的时间进行调整，保证项目提测与上线。</p>

<p>开发解决方案：</p>

<p>我感觉这是很重要的一步，以后也会按照这个步骤继续进行下去。就是在前期buffer中，要制定一份解决方案，该方案包括项目中可能回到的技术点与解决方式，如果可能的话，也可以有测试用例。这样，把所有的难点在开发前解决，真正到开发阶段，只是对方案的代码实现，可以提高开发效率。</p>

<h2 id="toc_2">3、接口</h2>

<p>第一次遇到接口问题，在功能已经实现后，接口进行更改，并且不是简单的接口替换，而是完全的接口分离，这样前端必须进行调整。</p>

<p>问题出现的原因：后端人员在实现接口的时候没有向吴总确认，直接在原先的接口中一并返回的品牌分类。后来吴总说，这是两个功能，应该有独立的接口。</p>

<p>这个过程中暴露了一个问题：太被动！前端跟着后端的接口走，不能做到完全的分离，容易受后端接口影响。</p>

<p>如何避免这种情况？下面是我想到的一些方法：</p>

<pre><code>// 沟通方向
1. 开发前，提前和后端（或其他端）沟通好，接口的内容
2. 该接口要得到确认，切实可行才可使用

// 规范方向
1. 由前端定义接口内容，这样不仅可以规范接口，前端还能脱离接口独立开发
2. 前端定义接口后后端确认，或者一起定接口。然后后端评估该接口，并进行确认
3. 尝试使用接口管理工具，并且该工具可以根据定义的接口形式自动生成测试数据
4. 或者前端建立统一的内部项目接口文档，涵盖该项目的所有接口，及时更新与维护
</code></pre>

<p>也没有想到其他更好的方法，但以后开发的时候会尝试先定义接口内容，然后向后端确认。接口需要考虑的内容主要为：</p>

<pre><code>1. 请求方式、参数名称、参数类型、参数说明、参数示例、接口URL

2. 返回数据，返回数据格式、属性名称、类型
</code></pre>

<p>上述中，后端进行第一行的设计，前端可进行第二行的设计。然后开发的时候就按照该设计内容就行开发，做到规范统一。</p>

<p>以上暂时是自己想到的途径，后期开发会按照更规范的方向解决问题。</p>

<h2 id="toc_3">4、测试</h2>

<p>从刚开始透出的问题中来看，自己在测试方面做的还很不好，这也是后期出现bug多的原因。减少出现bug和弄明白需求其实是一样的。</p>

<p>自己在之前开发的过程中，为了减少bug的出现、测试的比较充分完全，自己尝试进行测试记录，比如：</p>

<pre><code>开发完品牌筛选状态保存后，进行测试：

1. 从首页点击进入               正常
2. 从首页分类推荐进入            正常
3. 分类切换                     正常
4. 品牌切换                     正常
5. 分类切换后刷新页面            正常
6. 品牌切换后刷新页面            正常
7. 品牌筛选后，复制链接另外打开    正常
</code></pre>

<p>我觉得这是一个比较笨的方法，想方设法的找各种可能，常规的话，如果对需求了解的够深，基本上不会写出bug来。即使已经想了很多种可能，但是有时候还是会遗漏某一点，比如如果有与数据相关的时候，后台的数据也要进行多样化的测试，比如：所有的值是相同的，所有的值都是空的，一半空的、一半有值等。只能这样进行穷举似的测试。</p>

<p>这在以后可向他人进行请教，其他同学是如何进行自测的？如何写出健壮的程序来？</p>

<p>另外，也可以学习如何接入单元测试。比如：<a href="https://mochajs.org/">Mocha</a>，之前没有使用过单元测试的框架，需要投入精力去学习一下。这样的话，可以每次先写测试，然后测试通过在进行开发，也可以先开发，然后之后进行测试。这一阶段目前只停留在想法阶段，后期会集中精力进行学习。</p>

<h2 id="toc_4">优供1.5.1 项目简介</h2>

<p>前端v1.5.1上线内容</p>

<pre><code>1.  首页封闭：登录后查看商品及价格，策略服务器可控；
2.  支持秒杀活动；
3.  分类页支持品牌筛选，品牌支持后台配置；
4.  细节优化：
    5. 去结算货到在线支付文案提示；
    6. 购物车异常提示条UI优化；
    7. ios活动页规则文案限制问题；
</code></pre>

<p>后台V1.5.1上线内容：</p>

<pre><code>1.  秒杀商品管理，秒杀活动配置；
2.  分类页品牌配置；
3.  账号管理：查看账号优惠券明细；支持账号起送价（300/500）配置；
4.  订单管理优化：赠品在商品清单显示赠品标识。
</code></pre>

<p>评审时间：2016/4/14<br/>
提测时间：2016/4/28<br/>
预计上线：2016/5/10<br/>
实际上线：2016/5/13</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631573927160.html">Backbone：了解model的set与事件触发</a></h1>
			<p class="meta"><time datetime="2016-05-14T00:36:32+08:00" 
			pubdate data-updated="true">2016/5/14</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>之前认为对象的直接对比一直都是<code>false</code>，比如：</p>

<pre><code class="language-javascript">// Object
{} == {}        // false
{} === {}       // false
// Array
[] == []        // false
[] === []       // false
// Function 
var a = function (){};
var b = function (){};
a == b          // false
a === b         //false
// RegExp
/a/ == /a/      // false
/a/ === /a/     // false
</code></pre>

<p>于是，在使用Backbone的时候，也理所当然的认为当监听<code>change</code>事件的时候，只要model中的值发生变化，就会触发该事件，并执行相应的方法，因为在测试过程中没有发现有重复性内容，所以也就没有发现该想法存在的问题。</p>

<p>直到出现这种情况，在执行<code>Model</code>的<code>set</code>方法的时候，设置前和设置后，其对象key与value与上次设置的是相同的，此时不会触发change事件，而对于此时页面需要刷新时，将变得无能为力。</p>

<p>下面就看看Backbone是如何在<code>set</code>的时候，触发<code>change</code>事件的，这里先贴下set的相关代码：</p>

<pre><code class="language-javascript">// 设置模型的attributes属性，同时触发“change”事件. 
// 这是操作模型的最直接的方法，更新数据的时候，如果谁监听了该数据的变化，将会触发它
set: function(key, val, options) {
 // 如果没有内容传入，直接return
 if (key == null) return this;

 // 可以设置两种形式，一种是：(key, value)
 // 另一种是对象的形式：{ key: value}
 // 不管哪一种，attrs都保存了为第二种形式
 var attrs;
 if (typeof key === &#39;object&#39;) {
   attrs = key;
   options = val;
 } else {
   (attrs = {})[key] = val;
 }

 options || (options = {});

 // 进行参数验证
 // 可以在option中设置：{validate: false}可跳过验证
 // 验证失败，把消息设置在validationError上
 // 同时触发“invalid”事件，错误消息返回
 if (!this._validate(attrs, options)) return false;

 // Extract attributes and options.
 var unset      = options.unset;
 var silent     = options.silent;
 var changes    = [];   
 var changing   = this._changing;
 this._changing = true;
    
  // 
 if (!changing) {
   this._previousAttributes = _.clone(this.attributes);
   this.changed = {};
 }

 var current = this.attributes;
 var changed = this.changed;
 var prev    = this._previousAttributes;

 // 深度遍历，记录哪些属性发生变化
 // _.isEqual() 是对两个对象进行深度比较
 for (var attr in attrs) {
   val = attrs[attr];
   if (!_.isEqual(current[attr], val)) changes.push(attr);
   // 如果与上次的值相比没有变化，则在changed中删掉它
   if (!_.isEqual(prev[attr], val)) {
     changed[attr] = val;
   } else {
     delete changed[attr];
   }
   unset ? delete current[attr] : current[attr] = val;
 }

 // 每一次set都重新更新id值
 if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);


 // 事件触发
 // 如果传入{silent: true}，则不会触发任何事件
 if (!silent) {
   if (changes.length) this._pending = options;
   for (var i = 0; i &lt; changes.length; i++) {
     this.trigger(&#39;change:&#39; + changes[i], this, current[changes[i]], options);
   }
 }

 // Changes can be recursively nested within `&quot;change&quot;` events.
 if (changing) return this;
 if (!silent) {
   while (this._pending) {
     options = this._pending;
     this._pending = false;
     this.trigger(&#39;change&#39;, this, options);
   }
 }
 this._pending = false;
 this._changing = false;
 return this;
}
</code></pre>

<p>这里比较重要的是<code>underscore</code>的<code>_.isEqual()</code>方法，该方法用于判断两个对象是否相等，如果不相等，就把改变的属性对于的key，存到“changes”数组中。</p>

<p>不过，在这之前需要先了解一下<code>Backbone</code>中保存值时的三个状态：</p>

<ul>
<li>current：即通过this.attributes来获取，未设置值时当前的数据</li>
<li>previous：通过this.previousAttributes来获取，返回上一个模型的副本，一般用不到，不过回滚的时候回用到</li>
<li>now：将要set的值，是在执行model的set方法时传入的值</li>
</ul>

<p>很显然，需要将<code>now</code>中的值和<code>current</code>中的值进行对比，通过的<code>_.isEqual()</code>方法，下面看看该方法的具体实现（代码进行了简化）：</p>

<pre><code class="language-javascript">var eq = function(a, b, aStack, bStack) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  // null == undefined为true，但是这两个并不相同，需要判断
  if (a == null || b == null) return a === b;
  // 如果是underscore对象，先解压出来
  if (a instanceof _) a = a._wrapped;
  if (b instanceof _) b = b._wrapped;
  // 比较其数据类型，两种数据类型不同，返回false
  var className = toString.call(a);
  if (className !== toString.call(b)) return false;
  switch (className) {
    // 如果是字符串、数字、正则、日期、布尔的比较
    case &#39;[object RegExp]&#39;:
    // 正则表达式转化成字符串进行比较：&#39;&#39; + /a/i === &#39;/a/i&#39;
    case &#39;[object String]&#39;:
      return &#39;&#39; + a === &#39;&#39; + b;
    case &#39;[object Number]&#39;:
      if (+a !== +a) return +b !== +b;
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    // 对于日期和布尔，转化成数字进行比较
    case &#39;[object Date]&#39;:
    case &#39;[object Boolean]&#39;:
      return +a === +b;
  }
  
  // 递归比较对象和数组
  // 比较数组
  if (areArrays) {
    length = a.length;
    if (length !== b.length) return false;
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  // 比较对象
  } else {
    // 对象的深度比较
    var keys = _.keys(a), key;
    length = keys.length;
    // 确保比较前，两个对象包含相同的属性数量
    // 如果不相同，则不不满足比较规则，返回false
    if (_.keys(b).length !== length) return false;
    while (length--) {
      // 比较每一个属性值
      key = keys[length];
      // 规则：b有相同的属性，并且两个对象的该属性值相同，否则false
      if (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  return true;
};
</code></pre>

<p>重点的代码是最后的对象判断，先获取a，b中的key，组成数组，比较数组的长度，长度不相等，肯定对象不相等。</p>

<p>如果长度相等，然后比较属性值，两个对象具有相同的属性并且属性值也一样，则是相等的，否则，不相等。</p>

<p>可见，<code>Backbone</code>中进行比较的还是属性值，而不是进行的简单的对象判断。</p>

<p>到现在可以回答自己在一开始出现的疑问，对于基本类型，是进行的值对比，而对于对象类型，是判断其指针指向的内容地址进行判断。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631251677698.html">css3：radial-gradient</a></h1>
			<p class="meta"><time datetime="2016-05-13T15:39:27+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>径向渐变是圆形或椭圆形渐变，颜色不再沿着一条直线变化，而是从一个起点向所有房向混合。</p>

<h2 id="toc_0">一、语法</h2>

<p>-webkit-旧语法：</p>

<pre><code>-webkit-gradient(
    [&lt;type&gt;],[&lt;position&gt; || &lt;angle&gt;,]?
    [&lt;shape&gt; || &lt;size&gt;,]?
    &lt;color-stop&gt;,&lt;color-stop&gt;[,&lt;color-stop&gt;]
);
</code></pre>

<p>-webkit-新语法：</p>

<pre><code>-webkit-radial-gradient(
    [&lt;position&gt; || &lt;angle&gt;,]?
    [&lt;shape&gt; || &lt;size&gt;,]?
    &lt;color-stop&gt;,&lt;color-stop&gt;[,&lt;color-stop&gt;]
);
</code></pre>

<p>w3c标准语法：</p>

<pre><code>radial-gradient(
        [&lt;shape&gt; || &lt;size&gt;] 
        [at &lt;position&gt;]?,| at &lt;positon&gt;,]?
    &lt;color-stop&gt;[, &lt;color-stop&gt;]+
);
</code></pre>

<h2 id="toc_1">二、参数及使用</h2>

<h3 id="toc_2">1、shape 与size</h3>

<p>第二个参数是：shape与size，shape指径向渐变的形状，size指径向渐变的结束形状大小。其分别有如下参数：</p>

<h4 id="toc_3">1. shape，可省略，默认值：ellipse</h4>

<p><strong>circle</strong> ：渐变形状为圆形</p>

<pre><code>background: radial-gradient(circle, red, blue);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(circle, red, blue);"></div>

<p><strong>ellipse</strong> ：渐变形状为椭圆</p>

<pre><code>background: radial-gradient(ellipse, red, blue);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(ellipse, red, blue);"></div>

<h4 id="toc_4">2. 圆心定位</h4>

<p><code>at + 关键字 | 百分比</code>它指定渐变的中心点。如果省略，则取默认值“center”。</p>

<p>除了省略或“center”以外，还可以使用相应方向的关键字：</p>

<pre><code>background: radial-gradient(circle at top, red, blue);
background: radial-gradient(circle at bottom, red, blue);
background: radial-gradient(circle at center, red, blue);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(circle at top, red, blue);display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(circle at bottom, red, blue);display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(circle at center, red, blue);display: inline-block"></div>

<pre><code>background: radial-gradient(circle at top left, red, blue);
background: radial-gradient(circle at bottom right, red, blue);
background: radial-gradient(circle at center, red, blue);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(circle at top left, red, blue);display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(circle at bottom right, red, blue);display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(circle at center, red, blue);display: inline-block"></div>

<p>也可以是百分比：</p>

<pre><code>background: radial-gradient(circle at 100% 10%, red, blue);
background: radial-gradient(circle at 20% 20%, red, blue);
background: radial-gradient(circle at 80%, red, blue);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(circle at 100% 10%, red, blue);display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(circle at 20% 20%, red, blue);display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(circle at 80%, red, blue);display: inline-block"></div>

<h4 id="toc_5">3. size，可省略，默认值：farthest-corner</h4>

<p><strong>farthest-corner</strong> ：指定径向半径的长度为从圆心到离圆心最远的角</p>

<pre><code>background: radial-gradient(farthest-corner, red, black);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(circle farthest-corner, red, black);display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(farthest-corner, red, black);display: inline-block"></div>

<p><strong>closest-side</strong> ：指定径向渐变的半径长度从圆心到离圆心最近的边</p>

<pre><code>background: radial-gradient(closest-side, red, black);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(circle closest-side, red, black);display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(closest-side, red, black);display: inline-block"></div>

<p><strong>closest-corner</strong> ：指定径向半径长度为从圆心到离圆心最近的角</p>

<pre><code>background: radial-gradient(closest-corner, red, black);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(circle closest-corner, red, black);display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(closest-corner, red, black);display: inline-block"></div>

<p><strong>farthest-side</strong> ：指定径向半径的长度为从圆心到离圆心最远的边</p>

<pre><code>background: radial-gradient(farthest-side, red, black);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(circle farthest-side, red, black); display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(farthest-side, red, black); display: inline-block"></div>

<h4 id="toc_6">3. length 以及 length、percentage</h4>

<p>如果shape为circle，表明该径向渐变的形状为圆，size可以设置为length，指定渐变的直径长度。该长度不能为百分比，也不能为负值，因为其表示的是一个具体的长度。</p>

<pre><code>background: radial-gradient(circle 20px, red, black);
background: radial-gradient(circle 50px, red, black);
background: radial-gradient(circle 100px, red, black);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(circle 20px,red, black); display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(circle 50px,red, black); display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(circle 100px,red, black); display: inline-block"></div>

<blockquote>
<p>注意：如果只设置一个长度值，也可以省略<code>circle</code>关键字，因为一个长度就表示该椭圆的长轴和短轴相等，都是该数值。如下所示：</p>
</blockquote>

<pre><code>background: radial-gradient(80px, red, black);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(80px,red, black); display: inline-block"></div>

<p>如果shape参数是ellipse，表明该径向渐变的形状为椭圆，此时size可以设置两个数值，表示椭圆的水平半径与垂直半径。这两个值除了可以用size表示外，也可以用百分比表示。使用百分比的话是相对于渐变容器的边缘的尺寸，不能为负值。</p>

<pre><code>background: radial-gradient(ellipse 80px 30px, red, black);
background: radial-gradient(ellipse 150px 30px, red, black);
background: radial-gradient(ellipse 10px 80px, red, black);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(ellipse 80px 30px,red, black); display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(ellipse 150px 30px,red, black); display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(ellipse 10px 80px,red, black); display: inline-block"></div>

<blockquote>
<p>注意，如果设置两个数值，也可以省略<code>ellipse</code>关键字，两个数值就便是了长轴与短轴。如下示例：</p>
</blockquote>

<pre><code>background: radial-gradient(80px 30px, red, black);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(80px 30px,red, black); display: inline-block"></div>

<h3 id="toc_7">4、color-stop</h3>

<p>第三个参数就是设置的颜色值，径向渐变上的停止的颜色，和线性渐变类似。可以设置多个渐变色，也可是设置渐变色的百分比。</p>

<pre><code>background: radial-gradient(circle, red, black, green, yellow, pink);
background: radial-gradient(circle, red 0%, black 10%, green 50%, yellow 60%, pink 100%);
background: radial-gradient(100px 50px, red 30%, black, green, yellow, pink 100%);
</code></pre>

<div style="width: 200px; height: 100px; background: radial-gradient(circle, red, black, green, yellow, pink); display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(circle, red 0%, black 10%, green 50%, yellow 60%, pink 100%); display: inline-block"></div>
<div style="width: 200px; height: 100px; background: radial-gradient(100px 50px, red 30%, black, green, yellow, pink 100%); display: inline-block"></div>

<h2 id="toc_8">三、实例</h2>

<h2 id="toc_9">1. 模拟球体</h2>

<pre><code>div {
    width: 200px; 
    height: 200px;
    border-radius: 200px;
    box-shadow: 0 100px 70px -70px;
    background: radial-gradient(100px at top, #fff, #ccc);
}
</code></pre>

<div style="width: 200px; height: 200px; border-radius: 200px; background: radial-gradient(100px at top, #fff, #ccc); box-shadow: 0 100px 70px -70px; margin-bottom: 100px"></div>

<h2 id="toc_10">2. 色环</h2>

<pre><code>// 第二个，不设置色标位置
div {
    width: 200px;
    height: 200px;
    border-radius: 200px;
    background: radial-gradient(red, green, blue);
}
// 第一个，具体色标位置
div {
    width: 200px;
    height: 200px;
    border-radius: 200px;
    background: radial-gradient(red 20%, green 50%, blue 100%);
}
</code></pre>

<div style="width: 200px; height: 200px; border-radius: 200px; background: radial-gradient(red, green,blue);display: inline-block"></div>
<div style="width: 200px; height: 200px; border-radius: 200px; background: radial-gradient(red 20%, green 50%, blue 100%); display: inline-block"></div>

<h2 id="toc_11">3. 悬浮按钮</h2>

<iframe style="width: 100%; height: 220px" src="http://sandbox.runjs.cn/show/bzhl3dxd" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="toc_12"></h2>

<p>By: Gavin<br/>
2016.5.13</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631212906232.html">JavaScript：被忽视的细节</a></h1>
			<p class="meta"><time datetime="2016-05-13T14:34:50+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>《JavaScript 权威指南》这本书从第四版开始，一直到第六版，每个版本我都逐字逐句读过几遍，然而每一遍下来的感受却完全不一样。上上周的周一，再次翻开了这本犀牛书，这一次我是带着批判精神和研究精神过来的，所以看的时候也写下了一些感受和笔记，都是些容易被忽略的点，部分内容犀牛书上不一定有提到。 <br/>
之前都发在微博上，稍微整理了一番，放在这里，方便阅读。 </p>

<h2 id="toc_0">语句/表达式 </h2>

<p>换个角度理解语句（statemaents）和表达式（expressions）：表达式不会改变程序的运行状态，而语句会。还有一种叫做表达式语句，可以理解为表达式和语句的交集，如 <code>({a:1})</code>、<code>&quot;use strict;&quot;</code>等，我觉得没必要死扣，意义不大。</p>

<h2 id="toc_1">字符集</h2>

<p>ES3 要求 JS 必须实现 <code>Unicode 2.1</code> 及后续版本，而 ES5 只要求支持 <code>Unicode 3</code> 及后续版本。Unicode 字符 2005 年超过了十万字符，至今仍在不断增修，最新版本是 8.0。 </p>

<h2 id="toc_2">分号</h2>

<p> <br/>
如果你写 JS 代码不喜欢带分号，而又搞不清什么时候必须加分号，可以这么做：在以 <code>“(“</code>、<code>”[“</code> 、<code>”/“</code>、<code>”+”</code>、<code>”-“</code>开头的语句前面都加上一个分号，如 </p>

<pre><code>;(a + b).toString()。 
</code></pre>

<h2 id="toc_3">进制 </h2>

<p>ES5 严格模式中禁止使用八进制。目前各种引擎对 JS 的实现是存在差异的，部分支持八进制，部分不支持。八进制被禁止的原因：<code>String</code>和<code>Number</code>之间经常被相互转换，而以<code>0</code>开头的八进制数据特别容易让人迷惑，也容易让机器迷惑，比如<code>09</code>是该被转换成<code>9</code>还是直接报错？十六进制不存在这个问题，如 <code>0x98</code>。更多信息参阅 这里。</p>

<h2 id="toc_4">精度 </h2>

<p>JS 采用 <code>IEEE-754</code> 浮点数表示法，这是一种二进制表示法，由于精度原因 JS 不能表示所有的实数。它能展示的浮点数个数是有限的，比如它不能准确地表示三分之一的数值字面量。这也导致了它在浮点数的计算上存在误差，如 </p>

<pre><code>0.3 - 0.2 != 0.2 - 0.1
</code></pre>

<p>因为在计算的过程中，存在数据的溢出，丢失了精度。</p>

<pre><code>0.3 - 0.2 // 0.09999999999999998
0.2 - 0.1 // 0.1
</code></pre>

<h2 id="toc_5">null/undefined </h2>

<p>系统级、出乎意料的或者类似错误的值的空缺使用 <code>undefined</code>，而程序级、正常的或意料之中的值的空缺使用 <code>null</code>。平时编程给变量赋值时，不要使用 <code>undefined</code> 而应该用 <code>null</code>。值得注意的是 ES3 中的 undefined 是可以被重新赋值的，ES5 修复了这个 bug。通常我们使用 <code>void 0</code> 来还原/代替 undefined 的值。</p>

<h2 id="toc_6">eval </h2>

<p><code>eval</code> 是个不好把握的东西，它在 ES3 中更像是 <code>Function</code>，而在 ES5 中更像是一个运算符（严格模式下不允许设置别名，否则报错，且将其作为保留字）。实际上 ES3 中也不允许给 eval 设置别名，然而很多实现却依然允许，并将其作为全局代码来执行，浏览器尤其是 IE 对它实现相当混乱，没有什么规律可循，不过 IE 中提供了一个 <code>execScript</code> 函数，类似全局的 <code>eval</code>，这个函数每次执行都会返回 <code>null</code>。</p>

<p>需要使用 <code>eval</code> 的场景并不多，尽量少用，一般需求使用 <code>new Function</code> 就能满足。</p>

<h2 id="toc_7">引用 </h2>

<p>删除属性存在的坑：</p>

<pre><code>a = {
    n: {
        x: 2
    }
}, 
b = a.n; 
delete a.n; 
</code></pre>

<p>这段代码执行之后，b.x 依然等于 2，原因是 {x:2} 这个对象被 a 和 b 同时引用，delete 指令只删除了 a 对它的引用，b 上的引用依然存在。这种问题有可能造成内存泄漏。</p>

<h2 id="toc_8">Object 扩展 </h2>

<p><code>Object</code> 的 <code>freeze</code> 方法过于严格；<code>defineGetter/lookupGetter</code>和对应的 <code>Setter</code> 是很好用的属性。</p>

<pre><code>value
writable
enumerable
configurable

create -&gt; __proto__
get -&gt; __defineGetter__ / __lookupGetter
set -&gt; __defineSetter__ / __lookupSetter

defineProperty / defineProperties -&gt; isPeopertyOf / hasOwnProperty

getOwnPropertyName
getOwnPropertyDescriptor

preventExtensions -&gt; esExtensions

seals -&gt; isSealed
freeze -&gt; isFrozon 
</code></pre>

<h2 id="toc_9">toLocalString </h2>

<p>如图，你可能还不知道 JavaScript 的 <code>toLocaleString</code> 还可以这么玩。</p>

<pre><code>1234567..toLocaleString( &#39;zh-Hans-CN-u-nu-hanidec&#39;, {
    useGrouping: false
});
//一二三四五六七
1234567..toLocaleString( &#39;zh-Hans-CN-u-nu-hanidec&#39;, {
    useGrouping: true
});
//一,二三四,五六七 
</code></pre>

<h2 id="toc_10">this语义</h2>

<p>this 上下文只存在两种语义，一种是被当作方法调用，this 指向调用它的对象；一种是作为函数调用，指向 <code>Global</code> 对象（严格模式下为 undefined）。它没有作用域的限制，如下图所示，a 由于是作为函数被调用，所以它指向的是 window，故而返回 false。</p>

<pre><code>var o = {
    m: function () {
        var that = this;
        a();

        function a () {
            console.log( this === that );
        }
    }       
}
o.m();
// false
</code></pre>

<h2 id="toc_11">类型 </h2>

<p>JavaScript 可以被调用执行的均为 <code>Function</code> 类型，但是也存在可调用的 <code>Object</code>，如低版本 IE 中的一些宿主对象：<code>document.getElementById</code>、<code>alert</code> 等，在很多浏览器中<code>typeof</code> <code>RegExp</code> 同样是 Object。这绝对是一个不标准的实现，在浏览器摒弃/修正这些错误类型之前应该尽量少依赖它们。 </p>

<h2 id="toc_12">IE8 getter/setter </h2>

<p><code>Object.defineProperty</code> 虽然是 ES5 的东西，早在 IE8 就已经支持了，但支持得并不完善，比如 <code>writable</code>、<code>enumerable</code>、<code>configurable</code> 这些配置项设置就无效，IE8 下主要支持 <code>getter/setter</code>。</p>

<h2 id="toc_13">JSON.stringify </h2>

<p><code>JSON.stringify</code> 接受三个参数，很多人都知道第<code>三</code>个参数可以设置空白字符来美化输出，但是你可能不知道第<code>二</code>个参数的作用，它为 <code>{Array|Function}</code> 类型，如果为 <code>Array</code> 则用于过滤 <code>key</code>，如果为 <code>Function</code> 则可以对 <code>value</code> 做处理，如下。</p>

<pre><code>var obj = {
    a: {
        b: {
            c: 1,
            d: 2
        }
    }
}   JSON.stringify( obj, function ( k, v ) {
    if ( typeof v === &#39;number&#39; ) {
        return &#39;v&#39; + v;
    } else {
        return &#39;v&#39;;
    }
}, 2);
// output
&quot;{
    &quot;a&quot;: {
        &quot;b&quot;: {
            &quot;c&quot;: &quot;v1&quot;,
            &quot;d&quot;: &quot;v2&quot;
        }
    }
}&quot; 
</code></pre>

<h2 id="toc_14">Symbol </h2>

<p><code>ES6</code> 中添加了一种新的数据类型，<code>Symbol</code>，它是一种原始数据类型（图一），具备对象的特性（图二），并可以指向同一个引用（图三），能够作为对象的 <code>key</code> 但不可枚举（图四），内置的 <code>Symbol</code> 会影响程序的执行（图五），<code>Symbol.iterator</code> 是个举足轻重的符号，能够让元素具备迭代属性（图六），花样很多。<br/>
 附图见：<a href="http://weibo.com/1812166904/DqMwR8O6z">http://weibo.com/1812166904/DqMwR8O6z</a></p>

<p>伪数组添加 <code>Symbol.iterator</code> 的几个办法：鸭式辨型的 <code>iterator</code> 函数、<code>yield</code> 函数和直接使用 <code>Array</code> 的遍历符号。<br/>
 <br/>
附图见：<a href="http://weibo.com/1812166904/DqMBYe">http://weibo.com/1812166904/DqMBYebPw</a></p>

<h2 id="toc_15">Set/WeakSet</h2>

<p><code>Set/WeakSet</code> 这种数据结构，不能说没用，但确实也没啥大用，前者就是个不允许出现重复成员的数组，顺便还带了点 ES6 的特性，后者虽说可以一定程度上防止内存泄漏，但是也容易出错，比如某个引用已经被垃圾回收了，再去使用它可能就返回 null。它们都是 ES6 的配套产物。而 Map/WeakMap 倒是两个非常不错的设计，常规的 Object 结构都为 String-Val 键值对，而它扩展为 AllType-Val，任意类型都可以作为它的 Key，无论是服务端编程还是客户端编程，这个属性都带来了极大的便利性。</p>

<pre><code>var map = new Map();
var o = { a: 1 };

map.set( o, 555 );
map.get( o );
// 555  
</code></pre>

<h2 id="toc_16">正则 </h2>

<p>理解正则零宽的含义：正则中所谓的零宽断言，类似于锚点字符，它们匹配指定的位置而不会匹配内容，如 ^ 匹配开头，$ 匹配结尾，b 匹配单词边界；(?=p) 匹配「接下来的字符与 p 匹配」的位置，(?!p) 匹配「接下来的字符不与 p 匹配」的位置。b 字符匹配单词边界，实际上就是匹配 w 与 W 之间的位置（w 匹配 [a-zA-Z0-9]）。很少会有人用到 B，它匹配的是非单词边界位置，简单理解就是 w &amp; w 之间位置或者 W &amp; W 之间位置。</p>

<pre><code>&quot;hello    world&quot;.match(/\B\w+\B/g);
// [&#39;ell&#39;, &#39;orl&#39;]
&quot;hello     world&quot;.match(/\B\W+\B/g);
// [&#39;   &#39;]
</code></pre>

<p>持续学习和分享… </p>

<p>内容都是片段化的分享，比较多，也比较杂，就没有全部列举出来，感兴趣的同学可以 follow 我的 微博，我的想法和笔记都会在上面同步。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631211935835.html">谈谈HTTP协议中的短轮询、长轮询、长连接和短连接</a></h1>
			<p class="meta"><time datetime="2016-05-13T14:33:13+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p> <br/>
来源：伯乐在线专栏作者 - 左潇龙</p>

<p>链接：<a href="http://web.jobbole.com/85541/">http://web.jobbole.com/85541/</a><br/>
 </p>

<h2 id="toc_0">引言</h2>

<p>最近刚到公司不到一个月，正处于熟悉项目和源码的阶段，因此最近经常会看一些源码。在研究一个项目的时候，源码里面用到了HTTP的长轮询。由于之前没太接触过，因此LZ便趁着这个机会，好好了解了一下HTTP的长长短短。</p>

<p>了解的方式主要都是LZ在网络上获取的，这里只是谈一下LZ对于这四种叫法最直观的理解。如果你之前不懂的话，可以帮你普及一下，如果你之前就懂得话，可以互相对照一下。</p>

<h2 id="toc_1">以前的误解</h2>

<p>很久之前LZ就听说过长连接的说法，而且还知道HTTP1.0协议不支持长连接，从HTTP1.1协议以后，连接默认都是长连接。但LZ终究觉得对于长连接一直懵懵懂懂的，有种抓不到关键点的感觉。</p>

<p>今天LZ通过一番研究，终于明白了这其中的奥秘。而之前，LZ也看过长连接相关的内容，但一直都是云里雾里的。这次之所以能在这么短的时间里搞清楚，和LZ自己技术的沉淀密不可分。因此，这里LZ借着这个机会，再次强调一下，千万不要试图去研究你研究了很久都整不明白的东西，或许是你的层次不到，也或许是你从未在实际的应用场景接触过，这种情况下你去研究，只会事倍功半，徒劳一番罢了。</p>

<p>回到正题，既然说是误解，那么LZ的误解到底是什么？</p>

<p>那就是LZ一直认为，HTTP连接分为长连接和短连接，而我们现在常用的都是HTTP1.1，因此我们用的都是长连接。</p>

<p>这句话其实只对了一半，我们现如今的HTTP协议，大部分都是1.1的，因此我们平时用的基本上都是长连接。但是前半句是不对的，HTTP协议根本没有长短连接这一说，也正因为误解了这个，导致LZ对于长连接一直不明不白，始终不得其要领，具体下面一段会说到。</p>

<p>网络上很多文章都是误人子弟，根本没有说明白这个概念。这里LZ要强调一下，HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了，或者更准确的说，是本次HTTP请求就结束了，根本没有长连接这一说。那么自然也就没有短连接这一说了。</p>

<p>之所以网络上说HTTP分为长连接和短连接，其实本质上是说的TCP连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。 </p>

<p>其实知道了以后，会觉得这很好理解。HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。</p>

<p>一个形象的例子就是，拿你在网上购物来说，HTTP协议是指的那个快递单，你寄件的时候填的单子就像是发了一个HTTP请求，等货物运到地方了，快递员会根据你发的请求把货物送给相应的收货人。而TCP协议就是中间运货的那个大货车，也可能是火车或者飞机，但不管是什么，它是负责运输的，因此必须要有路，不管是地上还是天上。那么这个路就是所谓的TCP连接，也就是一个双向的数据通道。 </p>

<p>因此，LZ现在甚至觉得，“HTTP连接”这个词就不应该出现，它只是一个应用层的协议，根本就没有所谓的连接这一说，就像FTP也是应用层的协议，但是你有听说过FTP连接吗？（恩，好像是听过，但你现在知道了，其实所谓的FTP连接，严格来说，依旧是TCP连接）<br/>
 <br/>
实际上，说HTTP请求和HTTP响应会更准确一些，而HTTP请求和HTTP响应，都是通过TCP连接这个通道来回传输的。<br/>
 <br/>
不管怎么说，一定要务必记住，长连接是指的TCP连接，而不是HTTP连接。</p>

<h2 id="toc_2">一个疑问 </h2>

<p>之前LZ一直对一件事有些模糊不清，首先是怎么样就算是把HTTP变成长连接了，是不是只要设置Connection为keep-alive就算是了？<br/>
 <br/>
如果是的话，那都说HTTP1.1默认是长连接，而观察我们平时开发的Web应用的HTTP头部，Connection也确实是keep-alive，那就是说我们大部分都是用的长连接，但是长连接不是一般用于交互比较频繁的应用吗？像我们这种普通的Web应用，比如博客园这种，或者我的个人博客这种，长连接有什么用？<br/>
 <br/>
如果有用那用处到底是什么，我们又不是客户端与服务器交互频繁的那种应用（毕竟你打开网页肯定要半天才打开另外一个吧），如果没用的话，那到底应不应该把Connection为keep-alive这个header值给改掉，从而改成短连接？<br/>
 <br/>
这个疑问，在LZ明白了长连接其实是指的TCP连接之后，基本上就明白了。而这个疑问，也正是LZ在“以前的误解”那一段所提到的，那个因为误解导致LZ一直搞不明白的问题。</p>

<h2 id="toc_3">为什么解决了上面那个误解之后，前面所说的这些疑问LZ都明白了？</h2>

<p>因为长连接意味着连接会被复用，毕竟一直保持着连接不就是为了重复使用嘛。但如果长连接是指的HTTP的话，那就是说HTTP连接可以被重复利用，这个话听起来就感觉很别扭。之所以觉得别扭，其实就是LZ的一种直觉，没什么理论依据。而这种别扭的根源就在于，之前一直没有融会贯通的感觉，所以总感觉缺少点什么。不过这点疑惑，并没有影响LZ的工作，因此也就没深究过。<br/>
 <br/>
但现在好了，明白了长连接实际上是指的TCP连接，LZ瞬间自己就想明白了上面的那些问题。<br/>
 <br/>
第一个问题是，是不是只要设置Connection为keep-alive就算是长连接了？<br/>
 <br/>
当然是的，但要服务器和客户端都设置。<br/>
 <br/>
第二个问题是，我们平时用的是不是长连接？<br/>
 <br/>
这个也毫无疑问，当然是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上Connection都是keep-alive。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive）<br/>
 <br/>
第三个问题，也是LZ之前最想不明白的问题，那就是我们这种普通的Web应用（比如博客园，我的个人博客这种）用长连接有啥好处？需不需要关掉长连接而使用短连接？<br/>
 <br/>
这个问题LZ现在终于明白了，问题的答案是好处还是有的。</p>

<h2 id="toc_4">好处是什么？ </h2>

<p>首先，刚才已经说了，长连接是为了复用，这个在之前LZ就明白。那既然长连接是指的TCP连接，也就是说复用的是TCP连接。那这就很好解释了，也就是说，长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。<br/>
 <br/>
比如你请求了博客园的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这浪费了多少资源就不用LZ去说了吧。<br/>
 <br/>
但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。<br/>
 <br/>
这样一解释，就很明白了，不知道大家看了这些解释感觉如何，反正LZ在自己想明白以后，有种豁然开朗的感觉。<br/>
 <br/>
另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。<br/>
 <br/>
这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。现在想想，对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛，对不对？</p>

<h2 id="toc_5">长轮询和短轮询 </h2>

<p>前面基本上LZ已经把长短连接说的差不多了，接下来说说长短轮询，今天也正是为了研究长短轮询，LZ才顺便研究了下长短连接这回事。<br/>
 <br/>
短轮询相信大家都不难理解，比如你现在要做一个电商中商品详情的页面，这个详情界面中有一个字段是库存量（相信这个大家都不陌生，随便打开淘宝或者京东都能找到这种页面）。而这个库存量需要实时的变化，保持和服务器里实际的库存一致。<br/>
 <br/>
这个时候，你会怎么做？<br/>
 <br/>
最简单的一种方式，就是你用JS写个死循环，不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。<br/>
 <br/>
这种方式有明显的坏处，那就是你很浪费服务器和客户端的资源。客户端还好点，现在PC机配置高了，你不停的请求还不至于把用户的电脑整死，但是服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。</p>

<h2 id="toc_6">那怎么办呢？ </h2>

<p>长轮询这个时候就出现了，其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。<br/>
 <br/>
而对于客户端来说，不管是长轮询还是短轮询，客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。<br/>
 <br/>
这样一来，客户端的请求次数将会大量减少（这也就意味着节省了网络流量，毕竟每次发请求，都会占用客户端的上传流量和服务端的下载流量），而且也解决了服务端一直疲于接受请求的窘境。<br/>
 <br/>
但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是1000个人停留在某个商品详情页面，那就很有可能服务器这边挂着1000个线程，在不停检测库存量，这依然是有问题的。<br/>
 <br/>
因此，从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。之所以举这个例子，只是因为大家肯定都会网购，所以这个例子比较通俗一点。<br/>
 <br/>
哪怕轮询解决不了获取库存这个问题，但只要大家明白了长短轮询的区别，这就足够了。实际上，据LZ自己平日里购物的观察，那个库存量应该是不会变的，这个例子纯属LZ个人的意淫，-_-。</p>

<h2 id="toc_7">长短轮询和长短连接的区别</h2>

<p>这里简单说一下它们的区别，LZ这里只说最根本的区别。<br/>
 <br/>
第一个区别是决定的方式，一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。<br/>
 <br/>
第二个区别就是实现的方式，连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。</p>

<h2 id="toc_8">结语 </h2>

<p>好了，本文就到此为止吧。LZ写这篇文章，主要也是为了避免自己遗忘。说实话，写到最后了，LZ感觉对于它们的理解又进了一步，这就是写博客的好处吧。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631105630408.html">JavaScript：throttle and debounce</a></h1>
			<p class="meta"><time datetime="2016-05-13T11:36:03+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">1、概念介绍</h2>

<p>首先，<strong>throttling</strong> 与 <strong>debouncing</strong> 都可以对执行的函数进行速率限制。</p>

<p><strong>throtting</strong>：在一段时间内，对调用函数的最大次数进行限制，比如：在100ms内最多执行一次该函数。</p>

<p>举个例子，如果你的函数会在10s内执行1000次，比如触发<code>scroll</code>事件，这时候性能开销就比较大，我们可以使用throttle进行控制，让函数每100ms执行一次，这样，10s内最大执行的次数为100次，有效减少了性能开销。</p>

<p><img src="http://gavin-y.qiniudn.com/throttle.png" alt="throttle"/></p>

<p><strong>debouncing</strong>：经过一段时间以后才执行相应的函数。并且该函数只执行一次，比如：100ms以后才执行和这个函数。</p>

<p>举个例子：如果你的函数会在10s内执行1000次，比如触发<code>scroll</code>事件，当我们加上debounce的特效后，设置经过100ms后执行，Duang的一下，函数不会再这10s内执行了，相反，它会在事件结束后开始算起，经过100ms执行，也就是说在10.1s执行的该函数。</p>

<p><img src="http://gavin-y.qiniudn.com/debounce.png" alt=""/></p>

<h2 id="toc_1">2、演示</h2>

<p>在<a href="http://underscorejs.org/">underscore</a>中提供了<a href="http://underscorejs.org/#throttle">_.throttle()</a>与<a href="http://underscorejs.org/#debounce">_.debounce()</a>方法，下面使用这两个方法进行演示，可以明显的看到两个方法的不同。</p>

<p>代码如下：</p>

<pre><code>// throttle
$( window ).on( &#39;scroll&#39;, _.throttle( func, 200 ) );

// debounce
$( window ).on( &#39;scroll&#39;, _.debounce( func, 200 ) );
</code></pre>

<iframe style="width: 100%; height: 672px; border: 1px solid #ccc" src="http://sandbox.runjs.cn/show/xcdkk9av" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="toc_2">2、debounce</h2>

<p>上面演示了通过underscore提供的方法实现throttle与debounce，下面具体来看看怎么实现。我们先从最简单的debounce入手，假设只需要提供两个参数：</p>

<ul>
<li><strong>fn</strong>：回调函数</li>
<li><strong>wait</strong>：多长时间执行一次</li>
</ul>

<p>该部分实现比较简单，下面是实现代码：</p>

<pre><code>var debounce = function ( fn, wait ) {
    var timer = null;
    return function () {
        var context = this, args = arguments;
        clearTimeout( timer );
        timer = setTimeout( function () {
            fn.apply( context, args );
        }, wait );
    }
}
</code></pre>

<p>来演示一下：</p>

<pre><code>// 使用方式
var fn = function () {
    // do something
}
$( window ).on( &#39;scroll&#39;, debounce( fn, 200 ) );
</code></pre>

<iframe style="width: 100%; height: 240px; border: 1px solid #ccc" src="http://sandbox.runjs.cn/show/l9ybgqqo" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>上面通过闭包的方式来实现，因为当我们在调用debounce的时候执行的是一个函数，所以在debounce中，需要返回这么一个函数。</p>

<h2 id="toc_3">3、throttle</h2>

<p>上面说完了debounce的创建方式，下面说说throttle的创建方式。</p>

<p>其实，个人认为throttle是debounce的升级版，因为throttle是事件结束后然后在一段时间后才去执行相应函数，那么，有时候我们需要对这个执行过程进行控制，默认的浏览器渲染大约在16~17ms之间（通过最上面的demo的第一个可以看出），那么，如果是我们不想函数执行的这么频繁，即使50ms或者100ms也看不出任何的破绽，那么，我们宁愿使用100ms来执行函数，这也是throttle的作用。</p>

<p>下面我们还是实现比较简单的throttle，进行事件频率限制，同样，该方法接收两个参数：</p>

<ul>
<li><strong>fn</strong>：回调函数</li>
<li><strong>wait</strong>：每多少ms执行一次回调函数</li>
</ul>

<p>实现方式：</p>

<pre><code>var throttle = function ( fn, wait ) {\
    var last  = 0;
    return function () {
        var context = this;
        var curr = + new Date();
        if ( curr - last &gt;= wait ) {
            fn.call( context );
            last = curr;
        }
    }
}
</code></pre>

<p>使用方式：</p>

<pre><code>var fn = function () {
    // do something
}

$( window ).on( &#39;scroll&#39;, throttle( fn, 100 ) );
</code></pre>

<p>过程解释：</p>

<ul>
<li>一开始记录一个时间点</li>
<li>随着事件的触发，获取当前触发事件的时间点，判断该时间与事件开始时记录的时间相差是不是大于设定的值</li>
<li>如果大于设定的值，则执行函数</li>
<li>如果不大于，则什么也不做</li>
</ul>

<iframe style="width: 100%; height: 240px; border: 1px solid #ccc" src="http://sandbox.runjs.cn/show/r55gmjta" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="toc_4">4. 简单的封装实现</h2>

<pre><code>/**
 * throttle 
 * @param  fn, wait, debounce
 */
var throttle = function ( fn, wait, debounce ) {
    var timer = null,       // 定时器
        t_last = null,  // 上次设置的时间
        context,    // 上下文
        args,       // 参数
        diff;       // 时间差

    return funciton () {
        var curr = + new Date();
        var context this, args = arguments;
        clearTimeout( timer );
        if ( debounce ) {   // 如果是debounce
            timer = setTimeout( function () {
                fn.apply( context, args );
            }, wait );
        } else {            // 如果是throttle
            if ( !t_last ) t_last = curr;
            if ( curr - t_last &gt;= wait ) {
                fn.apply( context, wait );
                context = wait = null;
            }
        }
    }
}

/**
 * debounce
 * @param fn, wait
 */
var debounce = function ( fn, wait ) {
    return throttle( fn, wait, true );
}
</code></pre>

<p>注：该封装是一个简单的实现封装，抛掉了一些我自己觉得不必要存在的东西，比如说大多数的throttle的实现都有一个setTimeout的步骤，个人觉得如果时间小于多少的时候，timer会一直被覆盖没有发挥作用，所以就先去掉了。</p>

<h2 id="toc_5">5、underscore的实现方式理解</h2>

<pre><code>_.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;     // 定时器
    var previous = 0;       // 上次触发的时间
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();

      // 第一次是否执行
      if (!previous &amp;&amp; options.leading === false) previous = now;

      // 这里引入了一个remaining的概念：还剩多长时间执行事件
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      // remaining &lt;= 0 考虑到事件停止后重新触发或者
      // 正好相差wait的时候，这些情况下，会立即触发事件 
      // remaining &gt; wait 没有考虑到相应场景
      // 因为now-previous永远都是正值，且不为0，那么
      // remaining就会一直比wait小，没有大于wait的情况
      // 估计是保险起见吧，这种情况也是立即执行
      if (remaining &lt;= 0 || remaining &gt; wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;

      // 是否跟踪
      } else if (!timeout &amp;&amp; options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
};
</code></pre>

<p>由上可见，underscore考虑了比较多的情况：</p>

<ul>
<li>options.leading： 第一次是否执行，默认为true，表示第一次会执行，传入{leading:false}则禁用第一次执行</li>
<li>options.trailing：最后一次是否执行，默认为true，表示最后一次会执行，传入{trailing: false}表示最后一次不执行</li>
<li>所谓第一次是否执行，是刚开始触发事件时，要不要先触发事件，如果要，则previous=0，remaining 为负值，则立即调用了函数</li>
<li>所谓最后一次是否执行，是事件结束后，最后一次触发了此方法，如果要执行，则设置定时器，即事件结束以后还要在执行一次。</li>
<li>remianing &gt; wait 表示客户端时间被修改过。</li>
</ul>

<hr/>

<pre><code>// immediata 表示是否立即执行
_.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last &lt; wait &amp;&amp; last &gt;= 0) {
        // 该过程会频繁进行，直到last&gt;wait
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate &amp;&amp; !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      // 如果立即调用
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
};
</code></pre>

<h2 id="toc_6">6、使用场景</h2>

<ul>
<li>scroll resize 事件</li>
<li>文本输入自动完成</li>
<li>鼠标移动，拖动的情况</li>
<li>DOM元素的动态定位</li>
<li>......</li>
</ul>

<h2 id="toc_7">6、参考资料</h2>

<ul>
<li><p><a href="https://css-tricks.com/the-difference-between-throttling-and-debouncing/">https://css-tricks.com/the-difference-between-throttling-and-debouncing/</a></p></li>
<li><p><a href="http://www.css88.com/archives/4648">javascript函数的throttle和debounce</a></p></li>
<li><p><a href="http://www.alloyteam.com/2012/11/javascript-throttle/">浅谈javascript的函数节流</a></p></li>
<li><p><a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/">jQuery throttle / debounce: Sometimes, less is more!</a></p></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631105630335.html">JavaScript：scrollIntoView</a></h1>
			<p class="meta"><time datetime="2016-05-13T11:36:03+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>scrollIntoView可以实现让元素滚动到视图(可视)范围内，其接受一个可选参数，true / false</p>
</blockquote>

<h2 id="toc_0">1.使用方法</h2>

<p>使用方法：</p>

<pre><code>ele.scrollIntoView( arg );
</code></pre>

<h2 id="toc_1">2、参数介绍</h2>

<h3 id="toc_2">2.1 参数是boolean形式</h3>

<p>如果是：<code>true</code>，则表示元素滚动到视图的<code>顶部</code>，默认为<code>true</code></p>

<pre><code>ele.scrollIntoView( true );
</code></pre>

<p>如果是：<code>false</code>，则表示元素滚动到视图的<code>底部</code></p>

<pre><code>ele.scrollIntoView( false );
</code></pre>

<h3 id="toc_3">2.2 参数是对象形式</h3>

<blockquote>
<p>这种形式，目前只有firefox 36+支持。</p>
</blockquote>

<p>另外，其还接受一个对象格式：<code>scrollIntoViewOptions</code>，其有如下选项：</p>

<pre><code>{
    behavior: &quot;auto&quot;  | &quot;instant&quot; | &quot;smooth&quot;,
    block:    &quot;start&quot; | &quot;end&quot;
}
</code></pre>

<p>其中<code>behavior</code>默认是<code>instance</code>，<code>block</code>默认是<code>start</code>。</p>

<p>调用方式如下：</p>

<pre><code>ele.scrollIntoView({
  behavior: &quot;smooth&quot;,
  block:    &quot;end&quot;
});
</code></pre>

<blockquote>
<p>注意：</p>

<p>如果block是“start”，相当于设置了参数：true</p>

<p>如果block是“end”，相当于设置了参数：false</p>
</blockquote>

<h2 id="toc_4">3、具体示例</h2>

<p><a href="http://sandbox.runjs.cn/show/u1ogecdw">Demo地址</a></p>

<blockquote>
<p>注意：节点可能不会特别准确的滚动到滚动区域的上边界或者下边界，这取决于其他元素的布局。</p>

<p>Depending on the size of the given object and the current window, this method might not be able to put the item at the very top or very bottom, but will position the object as close to the requested position as possible.</p>
</blockquote>

<h2 id="toc_5">4、浏览器兼容性</h2>

<p><img src="http://7mj4a6.com1.z0.glb.clouddn.com/23482348923.png" alt="浏览器兼容性：http://7mj4a6.com1.z0.glb.clouddn.com/23482348923.png"/></p>

<h2 id="toc_6">5、scrollIntoViewIfNeeded(align)</h2>

<p>该属性和<code>scrollIntoView</code>属性类似，不同的是，这个属性可以实现自我判断，只有元素不在可视区域内才会滚动到可视区。</p>

<p>如果元素已经在可视区，则不会发生滚动。</p>

<p>该方法同样接受一个参数，是否居中显示，<code>true</code>表示垂直居中， <code>false</code>表示什么都不做。</p>

<h2 id="toc_7">5、资料来源</h2>

<ul>
<li><p><a href="https://www.w3.org/TR/2009/WD-html5-20090423/editing.html#dom-scrollintoview">https://www.w3.org/TR/2009/WD-html5-20090423/editing.html#dom-scrollintoview</a></p></li>
<li><p><a href="https://msdn.microsoft.com/en-us/library/ms536730(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/ms536730(v=vs.85).aspx</a></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoViewIfNeeded">https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoViewIfNeeded</a></p></li>
<li><p><a href="http://caniuse.com/#search=scrollintoview">http://caniuse.com/#search=scrollintoview</a></p></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14631105630249.html">JavaScript：Web Notifications</a></h1>
			<p class="meta"><time datetime="2016-05-13T11:36:03+08:00" 
			pubdate data-updated="true">2016/5/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">1、安全性</h2>

<p>要呈现通知需要获得用户的许可。</p>

<h2 id="toc_1">2、模型</h2>

<p>1、每个模型都有标题、方向、语言和来源</p>

<p>2、每个通知都要有与之相关的内容（body）、标签（tag）、图标地址（icon URL）和图标（icon image）。</p>

<h3 id="toc_2">2.1 direction</h3>

<h3 id="toc_3">2.2 language</h3>

<h3 id="toc_4">2.3 permission</h3>

<p>如果用户准许，就可以使用notification，其权限permission可以是如下三个字符串：</p>

<ul>
<li><code>default</code>: 和<code>denied</code>一样，只用户没有做出选择。</li>
<li><code>denied</code>: 指用户拒绝接收通知</li>
<li><code>granted</code>: 指用户同意展示通知</li>
</ul>

<h3 id="toc_5">2.4 notification list</h3>

<h3 id="toc_6">2.5 展示通知</h3>

<p>步骤：</p>

<h2 id="toc_7">方法</h2>

<table>
<thead>
<tr>
<th>事件处理器</th>
<th>事件类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>onclick</td>
<td>click</td>
</tr>
<tr>
<td>onshow</td>
<td>show</td>
</tr>
<tr>
<td>onerror</td>
<td>error</td>
</tr>
<tr>
<td>onclose</td>
<td>close</td>
</tr>
</tbody>
</table>

<h2 id="toc_8">一个通知构造的过程</h2>

<p>Notification(title, options);</p>

<p>1、实例化Notification通知对象</p>

<p>2、设置通知对象的标题</p>

<p>3、根据options中的<code>dir</code>设置通知对象的<code>direction</code></p>

<p>4、如果选项的<code>lang</code>存在，则设置<code>language</code>，否则设置为诶空</p>

<p>5、根据当前的源设置通知的来源</p>

<p>6、如果options中的<code>body</code>存在，设置通知的<code>body</code></p>

<p>7、如果options中的<code>tag</code>存在，设置通知的<code>tag</code></p>

<p>8、如果options中的<code>icon</code>存在，使用<code>API base URL</code>解析icon</p>

<p>9、返回通知，继续异步执行其他步骤</p>

<p>10、执行通知的展示步骤</p>

<h2 id="toc_9">展示通知的步骤</h2>

<p>1、如果通知源的权限不是<code>granted</code>，则取消任何的操作，执行error事件，终止其他步骤。</p>

<p>2、</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_1.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="JavaScript.html"><strong>JavaScript&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="jQuery.html"><strong>jQuery&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="css3.html"><strong>css3&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="other.html"><strong>other&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript.html"><strong>http&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Backbone.html"><strong>Backbone&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="14632088730610.html">优供1.5.1 项目总结</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14631573927160.html">Backbone：了解model的set与事件触发</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14631251677698.html">css3：radial-gradient</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14631212906232.html">JavaScript：被忽视的细节</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14631211935835.html">谈谈HTTP协议中的短轮询、长轮询、长连接和短连接</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>



</body>
</html>